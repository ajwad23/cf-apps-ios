// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file log.proto

import Foundation
import ProtocolBuffers


public func == (lhs: LogMessage, rhs: LogMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMessage_ == rhs.hasMessage_) && (!lhs.hasMessage_ || lhs.message_ == rhs.message_)
  fieldCheck = fieldCheck && (lhs.hasMessageType == rhs.hasMessageType) && (!lhs.hasMessageType || lhs.messageType == rhs.messageType)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = fieldCheck && (lhs.hasAppId == rhs.hasAppId) && (!lhs.hasAppId || lhs.appId == rhs.appId)
  fieldCheck = fieldCheck && (lhs.hasSourceType == rhs.hasSourceType) && (!lhs.hasSourceType || lhs.sourceType == rhs.sourceType)
  fieldCheck = fieldCheck && (lhs.hasSourceInstance == rhs.hasSourceInstance) && (!lhs.hasSourceInstance || lhs.sourceInstance == rhs.sourceInstance)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct LogRoot {
  public static var sharedInstance : LogRoot {
   struct Static {
       static let instance : LogRoot = LogRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final public class LogMessage : GeneratedMessage, GeneratedMessageProtocol {


    //Enum type declaration start 

    /// MessageType stores the destination of the message (corresponding to STDOUT or STDERR).
    public enum MessageType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case Out = 1
      case Err = 2

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .Out: return ".Out"
              case .Err: return ".Err"
          }
      }
    }

    //Enum type declaration end 

  /// Bytes of the log message. (Note that it is not required to be a single line.)
  public private(set) var message_:NSData = NSData()

  public private(set) var hasMessage_:Bool = false
  public private(set) var messageType:LogMessage.MessageType = LogMessage.MessageType.Out
  public private(set) var hasMessageType:Bool = false
  /// UNIX timestamp (in nanoseconds) when the log was written.
  public private(set) var timestamp:Int64 = Int64(0)

  public private(set) var hasTimestamp:Bool = false
  /// Application that emitted the message (or to which the application is related).
  public private(set) var appId:String = ""

  public private(set) var hasAppId:Bool = false
  /// Source of the message. For Cloud Foundry, this can be "APP", "RTR", "DEA", "STG", etc.
  public private(set) var sourceType:String = ""

  public private(set) var hasSourceType:Bool = false
  /// Instance that emitted the message.
  public private(set) var sourceInstance:String = ""

  public private(set) var hasSourceInstance:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasMessage_ {
      return false
    }
    if !hasMessageType {
      return false
    }
    if !hasTimestamp {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasMessage_ {
      try output.writeData(1, value:message_)
    }
    if hasMessageType {
      try output.writeEnum(2, value:messageType.rawValue)
    }
    if hasTimestamp {
      try output.writeInt64(3, value:timestamp)
    }
    if hasAppId {
      try output.writeString(4, value:appId)
    }
    if hasSourceType {
      try output.writeString(5, value:sourceType)
    }
    if hasSourceInstance {
      try output.writeString(6, value:sourceInstance)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMessage_ {
      serialize_size += message_.computeDataSize(1)
    }
    if (hasMessageType) {
      serialize_size += messageType.rawValue.computeEnumSize(2)
    }
    if hasTimestamp {
      serialize_size += timestamp.computeInt64Size(3)
    }
    if hasAppId {
      serialize_size += appId.computeStringSize(4)
    }
    if hasSourceType {
      serialize_size += sourceType.computeStringSize(5)
    }
    if hasSourceInstance {
      serialize_size += sourceInstance.computeStringSize(6)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<LogMessage> {
    var mergedArray = Array<LogMessage>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> LogMessage? {
    return try LogMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> LogMessage {
    return try LogMessage.Builder().mergeFromData(data, extensionRegistry:LogRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> LogMessage {
    return try LogMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> LogMessage {
    return try LogMessage.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> LogMessage {
    return try LogMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> LogMessage {
    return try LogMessage.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LogMessage {
    return try LogMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> LogMessage.Builder {
    return LogMessage.classBuilder() as! LogMessage.Builder
  }
  public func getBuilder() -> LogMessage.Builder {
    return classBuilder() as! LogMessage.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return LogMessage.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return LogMessage.Builder()
  }
  public func toBuilder() throws -> LogMessage.Builder {
    return try LogMessage.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:LogMessage) throws -> LogMessage.Builder {
    return try LogMessage.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasMessage_ {
      output += "\(indent) message_: \(message_) \n"
    }
    if (hasMessageType) {
      output += "\(indent) messageType: \(messageType.description)\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    if hasAppId {
      output += "\(indent) appId: \(appId) \n"
    }
    if hasSourceType {
      output += "\(indent) sourceType: \(sourceType) \n"
    }
    if hasSourceInstance {
      output += "\(indent) sourceInstance: \(sourceInstance) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMessage_ {
             hashCode = (hashCode &* 31) &+ message_.hashValue
          }
          if hasMessageType {
             hashCode = (hashCode &* 31) &+ Int(messageType.rawValue)
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          if hasAppId {
             hashCode = (hashCode &* 31) &+ appId.hashValue
          }
          if hasSourceType {
             hashCode = (hashCode &* 31) &+ sourceType.hashValue
          }
          if hasSourceInstance {
             hashCode = (hashCode &* 31) &+ sourceInstance.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "LogMessage"
  }
  override public func className() -> String {
      return "LogMessage"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return LogMessage.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:LogMessage = LogMessage()
    public func getMessage() -> LogMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasMessage_:Bool {
         get {
              return builderResult.hasMessage_
         }
    }
    public var message_:NSData {
         get {
              return builderResult.message_
         }
         set (value) {
             builderResult.hasMessage_ = true
             builderResult.message_ = value
         }
    }
    public func setMessage_(value:NSData) -> LogMessage.Builder {
      self.message_ = value
      return self
    }
    public func clearMessage_() -> LogMessage.Builder{
         builderResult.hasMessage_ = false
         builderResult.message_ = NSData()
         return self
    }
      public var hasMessageType:Bool{
          get {
              return builderResult.hasMessageType
          }
      }
      public var messageType:LogMessage.MessageType {
          get {
              return builderResult.messageType
          }
          set (value) {
              builderResult.hasMessageType = true
              builderResult.messageType = value
          }
      }
      public func setMessageType(value:LogMessage.MessageType) -> LogMessage.Builder {
        self.messageType = value
        return self
      }
      public func clearMessageType() -> LogMessage.Builder {
         builderResult.hasMessageType = false
         builderResult.messageType = .Out
         return self
      }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:Int64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(value:Int64) -> LogMessage.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> LogMessage.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = Int64(0)
         return self
    }
    public var hasAppId:Bool {
         get {
              return builderResult.hasAppId
         }
    }
    public var appId:String {
         get {
              return builderResult.appId
         }
         set (value) {
             builderResult.hasAppId = true
             builderResult.appId = value
         }
    }
    public func setAppId(value:String) -> LogMessage.Builder {
      self.appId = value
      return self
    }
    public func clearAppId() -> LogMessage.Builder{
         builderResult.hasAppId = false
         builderResult.appId = ""
         return self
    }
    public var hasSourceType:Bool {
         get {
              return builderResult.hasSourceType
         }
    }
    public var sourceType:String {
         get {
              return builderResult.sourceType
         }
         set (value) {
             builderResult.hasSourceType = true
             builderResult.sourceType = value
         }
    }
    public func setSourceType(value:String) -> LogMessage.Builder {
      self.sourceType = value
      return self
    }
    public func clearSourceType() -> LogMessage.Builder{
         builderResult.hasSourceType = false
         builderResult.sourceType = ""
         return self
    }
    public var hasSourceInstance:Bool {
         get {
              return builderResult.hasSourceInstance
         }
    }
    public var sourceInstance:String {
         get {
              return builderResult.sourceInstance
         }
         set (value) {
             builderResult.hasSourceInstance = true
             builderResult.sourceInstance = value
         }
    }
    public func setSourceInstance(value:String) -> LogMessage.Builder {
      self.sourceInstance = value
      return self
    }
    public func clearSourceInstance() -> LogMessage.Builder{
         builderResult.hasSourceInstance = false
         builderResult.sourceInstance = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> LogMessage.Builder {
      builderResult = LogMessage()
      return self
    }
    public override func clone() throws -> LogMessage.Builder {
      return try LogMessage.builderWithPrototype(builderResult)
    }
    public override func build() throws -> LogMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> LogMessage {
      let returnMe:LogMessage = builderResult
      return returnMe
    }
    public func mergeFrom(other:LogMessage) throws -> LogMessage.Builder {
      if other == LogMessage() {
       return self
      }
      if other.hasMessage_ {
           message_ = other.message_
      }
      if other.hasMessageType {
           messageType = other.messageType
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      if other.hasAppId {
           appId = other.appId
      }
      if other.hasSourceType {
           sourceType = other.sourceType
      }
      if other.hasSourceInstance {
           sourceInstance = other.sourceInstance
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> LogMessage.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> LogMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          message_ = try input.readData()

        case 16 :
          let valueIntmessageType = try input.readEnum()
          if let enumsmessageType = LogMessage.MessageType(rawValue:valueIntmessageType){
               messageType = enumsmessageType
          } else {
               try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntmessageType))
          }

        case 24 :
          timestamp = try input.readInt64()

        case 34 :
          appId = try input.readString()

        case 42 :
          sourceType = try input.readString()

        case 50 :
          sourceInstance = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}


// @@protoc_insertion_point(global_scope)
